<html>
	<head>
		<meta http-equiv="Cache-control" content="no-cache">
		<title>3DChart - Temperture tracker</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script type="module">
			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';
			
			var camera, controls, scene, renderer;
			// roomObject
			var room = {
				x: 15, 
				y: 12, 
				z: 13,
				meshArray: new Array(),
				GetYLimit: 0,
				getSize: function(){return this.x*this.y*this.z},
				getCroodFromIterator: function(iIterator){
					var v3Result = new THREE.Vector3();
					var reminder = Math.trunc(iIterator/this.x);
					return v3Result.set(iIterator%this.x, reminder%this.y, Math.trunc(reminder/this.z));
				}
			};
			
			init();
			//render(); // remove when using next line for animation loop (requestAnimationFrame)
			animate();

			function init() {
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0);
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 17.7, 19.8, 30 );
				// controls
				controls = new OrbitControls( camera, renderer.domElement );
				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;
				controls.screenSpacePanning = false;
				controls.minDistance = 10;
				controls.maxDistance = 40;
				controls.maxPolarAngle = Math.PI / 2;

				
				
				// fill the room
				for (var i=0;i<room.getSize();i++){
					room.meshArray.push(meshCube(room.getCroodFromIterator(i),"#"+(Math.trunc(Math.random()*0xFFFFFF)).toString(16).padStart(6, "0")));
					scene.add(room.meshArray[i]);
				}
				room.GetYLimit = room.y - 1;
				var axesHelper = new THREE.AxesHelper(9999);
				scene.add( axesHelper );
				
				window.addEventListener( 'resize', onWindowResize, false );
				
				window.addEventListener('keypress', function (e) {
					switch (e.key){
						case "=":
							room.GetYLimit += (room.GetYLimit>=room.y-1)?0:1;
							break;
						case "-":
							room.GetYLimit -= (room.GetYLimit<1)?0:1;
							break;
					}
					window.console.log(room.GetYLimit);
					//update visible
					for (var i=0;i<room.getSize();i++){
						room.meshArray[i].visible = (room.getCroodFromIterator(i).y<=room.GetYLimit);
					}
				});
				
			}
			
			function meshCube( vt3, hexColor=0xffffff){
				var geometry = new THREE.BoxGeometry( 1, 1, 1);
				var material = new THREE.MeshBasicMaterial({color: hexColor});
				var mesh = new THREE.Mesh( geometry, material )
				scene.add(mesh);
				mesh.position.copy(vt3);
				geometry.dispose();
				material.dispose();
				return mesh;
			};

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				setTimeout( function() {
					requestAnimationFrame( animate );
				}, 1000 / 60 );//Limit fps
				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>